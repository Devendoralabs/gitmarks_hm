<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<link href="/cssjs/style.css" media="screen" rel="stylesheet" type="text/css"></link>
<link href="/cssjs/common.css" media="screen" rel="stylesheet" type="text/css"></link>
<link href="/cssjs/lytebox/lytebox.css" media="screen" rel="stylesheet" type="text/css"></link>
<script src="/cssjs/lytebox/lytebox.js" language="javascript" type="text/javascript"></script>
<title>Why is Python more fun than Java?</title>
</head>

<body>

<!-- BANNER -->

<div class="banner-background">
  <div class="banner">

    <div class="banner-image">
    <a href="/id/4/"><img src="/images/brizzled.png" width="341" height="56" border="0" align="left"/></a>
    </div>

    <div class="banner-tagline">It'll only sting a little</div>

    <div class="banner-nav">
      <div class="text-button" style="width: 7em"><a href="/">top</a></div>
      <div class="text-button" style="width: 7em"><a href="/everything.html">everything</a></div>
    </div>
  </div>
</div>

<!-- GUTTER -->

<div class="gutter">
  <div class="gutter-item"></div>

  <div class="gutter-item">
    <a href="/about-me.html" rel="lyteframe" title="Brian M. Clapper" rev="">
    <img border="0" src="/images/bmc-2010-10-31.jpg" width="90" height="82" align="left">
    </a>
  </div>
  
  <div class="gutter-item">
    <div class="email">bmc&nbsp;@&nbsp;clapper.org</div>
  </div>

  <div class="gutter-item">
    <div class="text-button">
      <a href="/about-me.html" rel="lyteframe" title="Brian M. Clapper"
         rev="" class="button">About me</a>
    </div>
  </div>

  <div class="gutter-item">
    <a title="Full-content Atom feed" href="/atom.xml" class="button"><img src="/images/atom-small.gif" width="32" height="15" border="0" align="left"></a>
  </div>



  <div class="gutter-item">
    <span class="article-ref-header">LAST 20 ARTICLES</span>
    <ul class="article-ref-list">

      <li><a href="/id/104/index.html">Getting Delicious bookmarks to Diigo</a>

      <li><a href="/id/103/index.html">Writing, Markdown and Pandoc</a>

      <li><a href="/id/102/index.html">Curry</a>

      <li><a href="/id/101/index.html">Scala in Philly</a>

      <li><a href="/id/100/index.html">SBT and Your Own Maven Repository</a>

      <li><a href="/id/99/index.html">Programming Command-line Completion in Scala</a>

      <li><a href="/id/98/index.html">Parsing Markdown in Scala</a>

      <li><a href="/id/97/index.html">Loving Scala 2.8</a>

      <li><a href="/id/96/index.html">Good Skeptical Podcasts</a>

      <li><a href="/id/95/index.html">How Not to Design a Database</a>

      <li><a href="/id/94/index.html">Beginning Scala considered useful</a>

      <li><a href="/id/93/index.html">C# is now a better language than Java</a>

      <li><a href="/id/92/index.html">SBT: A Scala-based Simple Build Tool</a>

      <li><a href="/id/91/index.html">A spam poem</a>

      <li><a href="/id/90/index.html">Mac OS X, iTerm, bash key bindings, and muscle memory</a>

      <li><a href="/id/89/index.html">Readline support in Scala's REPL</a>

      <li><a href="/id/88/index.html">Scala and Python: An informal TCP performance benchmark</a>

      <li><a href="/id/87/index.html">A Scala build tool</a>

      <li><a href="/id/86/index.html">When the furnace goes out</a>

      <li><a href="/id/85/index.html">Interpreting Java</a>

    </ul>
  </div>
</div>

<div id="content-box">
    


<div id="articles-box">
<div id="articles-container">

<div class="article">

<div class="article-header">

  <div class="article-title">
  <a href="/id/75/index.html" class="reference">Why is Python more fun than Java?</a>
  </div>

  <div class="article-timestamp">Monday, 28 July, 2008</div>

</div>


<script type="text/javascript" src="/cssjs/toc.js">
<!-- -->
</script>


<div class="article-body" id="content">


<div id="tocBlock">
<span id="tocHeading">Table of Contents</span>
<div id="toc"></div>
</div>


<h1 id='intro'>Intro</h1>

<p>For <a href='http://www.clapper.org/bmc/resume/summary-resume.html#FullTilt'>nearly nine years</a>, I worked almost exclusively in <a href='http://java.sun.com/'>Java</a>. For me, Java was a productivity enhancer, over C and C++, and I greatly enjoyed working in it. Lately, however, I&#8217;ve been programming in <a href='http://www.python.org/'>Python</a> almost exclusively, and I&#8217;m having so much fun with it that I have little desire to go back to programming in Java.</p>

<p>Given that I developed code quite happily in Java for a long time, this is an interesting, though not unprecedented, turn of events.</p>

<p>I&#8217;ve been mulling over why I find programming in Python to be so much more fun . In this article, I am going to capture and explore some of those thoughts.</p>

<p>But first, a few caveats and disclaimers:</p>

<ul>
<li>These comments are <em>entirely</em> subjective. I am not attempting a rational, scientific, rigorous analysis of these two languages; nor do I claim to be making a comprehensive comparison of Java and Python. I&#8217;m only sharing some musings.</li>

<li>I do <em>not</em> suddenly hate Java. If you&#8217;re a Java enthusiast and this article makes you want to yank out the <a href='http://en.wikipedia.org/wiki/Napalm'>napalm</a>, realize that (a) I&#8217;m not bashing Java, and (b) I&#8217;m wearing my <a href='http://www.catb.org/jargon/html/A/asbestos-longjohns.html'>asbestos longjohns</a>. I&#8217;ve been a Java programmer for a long time, and I bear no ill will toward a language I happily used for many years. I&#8217;m just trying to capture why I find Python to be more fun.</li>

<li>I am ignoring architectural reasons to favor one platform over the other. In a real system, these considerations must be taken into account. I&#8217;m ignoring them here because I am <em>only</em> trying to figure out why the Python programming language seems to be more fun to program than Java does (to me).</li>

<li>I&#8217;m not a mindless Python fanboy. I was honestly surprised by how much fun I found Python programming to be, and I&#8217;ve been mentally exploring <em>why</em> I find it so much fun. This article is really little more than a brain dump of those thoughts.</li>

<li>I&#8217;m sure Your Favorite Language is every bit as much fun as Python, but I&#8217;m not programming in Your Favorite Language right now. I&#8217;m comparing one language I used almost exclusively for nine years with another one I&#8217;ve delved into very deeply in this last year.</li>
</ul>

<p>Having said all that, there will still be people who bash me and this article because (a) they think I&#8217;m disrespecting their Java, (b) they think I&#8217;ve left out some important stuff, (c) they&#8217;re annoyed that I didn&#8217;t consider how much fun Groovy or Erlang or Ruby or &#8230; are, (d) view me as some sort of Java <a href='http://en.wikipedia.org/wiki/Benedict_Arnold'>Benedict Arnold</a> or (e) they just don&#8217;t like what I have to say.</p>

<p>Oh, well.</p>

<p><em>adjusts longjohns</em></p>

<p>I&#8217;ve organized this article as a set of observations, with an explanation of my thinking immediately following each observation.</p>

<h1 id='observation_1_python_is_a_unique_mixture_of_readability_and_brevity'>Observation 1: Python is a unique mixture of readability and brevity</h1>

<p>The first reaction nearly <em>everyone</em> has about Python is, &#8220;Indentation is part of the language&#8217;s syntax? Yuck!&#8221; That was my first reaction, too. But, as it turns out, that feature contributes greatly to Python&#8217;s readability. Most people indent their code <em>anyway</em>, but most languages ignore indentation; they rely, instead, on syntax elements (curly braces, <code>do</code> and <code>end</code> keywords, etc.) to determine where code blocks begin and end. Python&#8217;s awareness of indentation dispenses with the need for curly braces or <code>do</code>/<code>end</code> keywords, leading to a brevity of syntax that still retains its readability.</p>

<p>As an example, compare the following Java code and Python code snippets, both of which do the same job.</p>

<p>Java:</p>

<pre><code>public class Test
{
     public static void main(String[] args)
     {
         for (String s : args[0].split(&quot;\\s+&quot;))
             System.out.println(s);

         System.exit(0);
     }
}</code></pre>

<p>Granted, the <code>System.exit(0)</code> doesn&#8217;t really need to be there; I got in the habit of putting it in, though, when using versions of Java that wouldn&#8217;t exit properly without such a call. But even if you remove that line, it&#8217;s still more verbose than the Python version:</p>

<pre><code>import sys

for s in sys.argv[1].split():
    print s</code></pre>

<p>Yes, I could make the Java example shorter by putting the braces on the same line as the code, as most people do, but I actually find that to be even <em>less</em> readable. (That&#8217; a personal stylistic preference. It has little to do with the real point of this article.)</p>

<p>The point is, Python&#8217;s syntax is brief without being overly terse.</p>

<p>But it gets even more pronounced.</p>

<h1 id='observation_2_no_need_for_setget_methods_in_python'>Observation 2: No need for set/get methods in Python</h1>

<p>Python code doesn&#8217;t typically use the <code>get</code> and <code>set</code> methods so common in Java. Normally, when writing Java code, you carefully protect your instance variables by making the private, so callers can only interact with them via getter and setter methods. Why? Well, consider this scenario. Suppose you write a class called <code>Point</code> that looks something like this:</p>

<pre><code>public class Point
{
    public int x;
    public int y;

    public Point(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
}</code></pre>

<p>Pretty soon, all over the code base, people are writing code like this:</p>

<pre><code>point1 = Point(...)
point2 = Point(...)
point2.x = point1.x - deltaX
point2.y = point1.y - deltaY</code></pre>

<p>That&#8217;s actually quite readable, but there&#8217;s a problem: Suppose your requirements change, and now you have to ensure that all coordinates are positive.</p>

<p>Crap.</p>

<p>Now you realize that you <em>should</em> have written your <code>Point</code> class like this:</p>

<pre><code>public class Point
{
    private int x;
    private int y;

    public Point(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    public int getX()
    {
        return this.x;
    }

    public int setX(int newX)
    {
        this.x = newX;
    }

    public int getY()
    {
        return this.y;
    }

    public int setY(int newY)
    {
        this.y = newY;
    }
}</code></pre>

<p>If you&#8217;d written it <em>that</em> way, people would&#8217;ve had to use it like this:</p>

<pre><code>point1 = Point(...)
point2 = Point(...)
point2.setX(point1.getX() - deltaX)
point2.setY(point1.getY() - deltaY)</code></pre>

<p><code>point2.setX(point1.getX() - deltaX)</code> isn&#8217;t anywhere near as intuitive or nice-looking as <code>point2.x = point1.x - deltaX</code>, but it&#8217;s a lot safer. And if you&#8217;d written it that way, you would only have to go into the <code>set()</code> methods and add your constraint checks to ensure the arguments are positive, without having to go change a whole bunch of calling code. For instance:</p>

<pre><code>public int setX(int newX)
{
    if (newX &gt; 0)
        throw new IllegalArgumentException(&quot;Negative X value.&quot;);

    this.x = newX;
}</code></pre>

<p>Okay, why is Python&#8217;s solution to this problem more readable? Because Python has a neat construct called a <em>property</em>. As Python&#8217;s inventor, Guido van Rossum, puts it:</p>

<blockquote>
<p>Properties are a neat way to implement attributes whose usage resembles attribute access, but whose implementation uses method calls. These are sometimes known as &#8220;managed attributes&#8221;.</p>
</blockquote>

<p>Basically, a property is a way to make a function call look like an instance variable reference. Let&#8217;s take our example, above, and do it in Python. First, the <code>Point</code> class:</p>

<pre><code>class Point(object):

    def __init__(self, x, y):
        self.x = x
        self.y = y</code></pre>

<p>(You&#8217;ll note that it&#8217;s a tad shorter than the equivalent Java class, while being just as readable.)</p>

<p>So, as before, people start using your <code>Point</code> class:</p>

<pre><code>point1 = Point(...)
point2 = Point(...)
point2.x = point1.x - delta_x
point2.y = point1.y - delta_y</code></pre>

<p>Okay, now along comes that pesky requirement that all coordinates must be positive. Instead of going back and changing all the callers to use new <code>set</code> methods, you can simply wrap access to <code>x</code> and <code>y</code> in functions, as show below.</p>

<pre><code>class Point(object):

    def __init__(self, x, y):
        self.__x = x
        self.__y = y

    def getx(self):
        return self.__x

    def setx(self, newx)
        if newx &gt; 0:
            raise ValueError, &#39;Negative X value&#39;

        self.__x = newx

    x = property(getx, setx, doc=&#39;X coordinate&#39;)

    def gety(self):
        return self.__y

    def sety(self, newy)
        if newy &gt; 0:
            raise ValueError, &#39;Negative Y value&#39;

        self.__y = newy

    y = property(gety, sety, doc=&#39;Y coordinate&#39;)</code></pre>

<p>Now, whenever someone writes <code>point.x</code>, they&#8217;re really calling <code>point.getx()</code>. Similarly, <code>point.x = 1</code> results in a call to the <code>point.setx()</code> method.</p>

<p>You&#8217;ve added getters and setters, but the callers of your <code>Point</code> class still get to use the original, simpler, easier-to-read syntax for accessing the value. You get the best of both worlds: clean and simple client access to your <code>Point</code> class, and protection and flexibility <em>within</em> the class.</p>

<p>Again, this tends to lead to more readable code.</p>

<h1 id='observation_3_python_has_useful_constructs_java_lacks'>Observation 3: Python has useful constructs Java lacks</h1>

<p>Python has some features that both make it easier to code certain common constructs and contribute to the resulting code&#8217;s readability. Here are a few examples.</p>

<h2 id='function_objects'>Function Objects</h2>

<p>In Python, functions are first class objects. That is, you can define a function pretty much anywhere you want, then call it or use a reference to it. This is beneficial in many areas, but for illustration, I&#8217;ll focus on just two:</p>

<ul>
<li>Callbacks</li>

<li>Factory methods</li>
</ul>

<h3 id='callbacks'>Callbacks</h3>

<p>Between interfaces and inner classes, Java can accomplish a lot of the things people use callback functions for, but functions are more compact, more flexible, and easier to read.</p>

<p>For example, consider a function to traverse a data structure (a tree, for instance) to find objects that match certain criteria. The matching function is generic: It traverses the structure and calls a caller-supplied matching function to match two objects. It makes sense to have the tree class supply the matching logic (which hides the details of efficiently traversing the tree), while allowing the caller to specify the matching function.</p>

<p>Here&#8217;s how you might implement that logic in Java, using an interface.</p>

<pre><code>import java.util.Collection;
import java.util.ArrayList;

public interface Matcher&lt;T&gt;
{
    boolean matches(T o);
}

public class MyTree&lt;T&gt;
{
    // details omitted

    Collection&lt;T&gt; matches(Matcher matcher)
    {
        Collection&lt;T&gt; result = new ArrayList&lt;T&gt;();

        for (element : this.treeElements)
            if (matcher.matches(element))
                result.add(element);

        return result;
    }
}</code></pre>

<p>And here&#8217;s how a caller might use it, using an anonymous inner class:</p>

<pre><code>MyTree&lt;String&gt; keywords = new MyTree&lt;String&gt;();

// Code that fills the tree goes here

// Now, get all keywords starting with &#39;a&#39;. (Yeah, it&#39;s contrived...)

Collection&lt;String&gt; matches = keywords.matches
    (new Matcher&lt;String&gt;()
     {
         public boolean matches(String s)
         {
             return s.startsWith(&quot;a&quot;);
         }
     });</code></pre>

<p>Now let&#8217;s look at the same thing in Python. First the class:</p>

<pre><code>class MyTree(object):

    # details omitted

    def matches(self, match_func):
        return [element for element in self.__tree_elements if match_func(element)]</code></pre>

<p>And now the caller:</p>

<pre><code>keywords = MyTree()

# Code that fills the tree goes here

# Now, get all keywords starting with &#39;a&#39;.

matches = keywords.matches(lambda element: element.startswith(&#39;a&#39;))</code></pre>

<p>It&#8217;s also possible to use a &#8220;real&#8221; function, rather than a <code>lambda</code>:</p>

<pre><code>def match(element):
    return element[0] == &#39;a&#39;

matches = keywords.matches(match)</code></pre>

<p>In simple cases like this, however, it&#8217;s easier and more straightforward to use a lambda.</p>

<p>Once again, the Python code is simpler and (in my opinion) easier to read and faster to code.</p>

<h3 id='factories'>Factories</h3>

<p>In Java, a factory is typically a static method that is called to produce an object. Factories are used for a variety of reasons, including:</p>

<ul>
<li>Construction of singletons.</li>

<li>Hiding instantiation of one of several possible underlying implementations.</li>
</ul>

<p>In Java, since methods cannot occur outside of a class, you are sometimes forced to write a class just to provide a factory function. Here&#8217;s an example. Consider a remote procedure call (RPC) layer that has many different RPC implements (e.g., &#8220;XML-RPC&#8221;, &#8220;JSON-RPC&#8221;, &#8220;SOAP&#8221;, etc.) Each implementation is encoded in a concrete class, and all classes adhere to a specific interface:</p>

<pre><code>public interface RPC
{
    public Object callRemote(String function, Object ... args);
}

class XMLRPC implements RPC
{
    // ...

    public Object callRemote(String function, Object ... args)
    {
        // ...
    }
}

class JSONRPC implements RPC
{
    // ...

    public Object callRemote(String function, Object ... args)
    {
        // ...
    }
}

// etc.</code></pre>

<p>Now, suppose your application is going to support a configuration option that allows the user to specify the desired RPC mechanism using a string, and you want to map that string to an instance of the appropriate RPC class. The easiest solution is a factory method. But where to you put that method? You can&#8217;t hang it off the <code>RPC</code> interface, because that&#8217;s just an interface. You have two choices:</p>

<ol>
<li>
<p>Convert the <code>RPC</code> interface to an abstract class, and put the method there. Doing that, of course, means that RPC subclasses can&#8217;t extend any other abstract classes, which may cause some implementation headaches (or might not, depending).</p>
</li>

<li>
<p>Create a special <code>RPCFactory</code> class, which is clumsy, but is probably the safest way to go.</p>

<p>public class RPCFactory { public static RPC getRPC(String identifier) { if (identifier.toLowerCase().equals(&#8220;xmlrpc&#8221;)) return new XMLRPC() &#8230; } }</p>
</li>
</ol>

<p>With Python, it&#8217;s easier: Simply create a factory method right in your module. To make things even simpler, you can use a hash table to look up the implementing classes. (You can do that with Java, too, but you end up having to use the Reflection API, which is clumsier than in Python. (See <em>Observation 4: Introspection is easier in Python</em>, below.)</p>

<pre><code>RPC_CLASSES = {&#39;xmlrpc&#39;  : XMLRPC,
               &#39;jsonrpc&#39; : JSONRPC,
               ... }

def get_rpc(identifier):
    try:
        return RPC_CLASSES[identifier]()
    except KeyError:
        raise ValueError, &#39;&quot;%s&quot; is an unknown RPC type&#39; % identifier</code></pre>

<h2 id='closures'>Closures</h2>

<p>Python doesn&#8217;t have true closures, in the Ruby or LISP sense of the term, but it&#8217;s a heck of a lot closer than Java. While there are proposals to add (true) closures to Java (such as <a href='http://javac.info/'>this one</a>), it doesn&#8217;t have them yet, and it may be awhile until it does.</p>

<p>The closest thing Java has to a closure is an anonymous inner class, and it isn&#8217;t really a closure. It&#8217;s also clumsy to use and can lead to less readable code.</p>

<p>I&#8217;m not going to go into the differences between inner classes and closures; there are plenty of discussions on that issue already. For further reading, here are a few pointers:</p>

<ul>
<li><a href='http://fishbowl.pastiche.org/2003/05/16/closures_and_java_a_tutorial'>Closures and Java: A Tutorial</a></li>

<li><a href='http://notdennisbyrne.blogspot.com/2008/06/yet-another-reason-for-why-java-needs.html'>Yet another reason for why Java needs Closures</a></li>
</ul>

<p>Since I&#8217;m mostly concerned about &#8220;fun&#8221;, readability and productivity, let&#8217;s look at one example. Closures are useful for a <em>lot</em> of things; this is just one simple example. I&#8217;ve adapted this scenario from <a href='http://gafter.blogspot.com/'>Neal Gafter</a>&#8217;s <a href='http://gafter.blogspot.com/2006/08/use-cases-for-closures.html'>Use cases for closures</a> blog entry.</p>

<p>The situation is simple: You have to provide a function that increments a counter for a key; the counters are stored in a hash table-like object. If the counter for a key isn&#8217;t present, then it must be created and initialized to 1. The wrinkle is that the hash table-like object is in a shared resource. (Perhaps it&#8217;s a file, or perhaps it&#8217;s shared memory; that part doesn&#8217;t matter here.) Since the table is shared, it must be locked to prevent corruption. You have to be sure to release the lock, even if an error occurs.</p>

<p>The standard pattern for this approach (using Python, in this case) is something like:</p>

<pre><code>def increment(key):
    self.lock.lock()
    try:
        value = self.counter_table.get(self, key)
        if not value:
            self.counter_table.add(key, 1)
            value = 1
        return value
    finally:
        lock.unlock()</code></pre>

<p>There are two problems with that code:</p>

<ol>
<li>You end up with that locking pattern all over your code. Wouldn&#8217;t it be nice to hide it somewhere? Wouldn&#8217;t it <em>really</em> be nice if it were part of the lock API?</li>

<li>The lock API cannot enforce that pattern. The requirement can be documented it, and the documentation can wag its finger (as it were) at the programmer, saying, &#8220;Always, always, <em>always</em> make sure you release your locks!&#8221; But it cannot <em>enforce</em> the restriction programmatically. And if someone forgets the <code>finally</code> block, he&#8217;ll introduce a bug&#8211;one that&#8217;s often tricky to track down.</li>
</ol>

<p>Closures solve that problem. Using closures, you can augment the locking API (or write a local front-end function) that looks like this:</p>

<pre><code>def with_lock(lock, action, *args, **keyword_args):
    try:
        lock.lock()
        action(*args, **keyword_args)
    finally:
        lock.unlock()</code></pre>

<p>Now our function becomes much simpler:</p>

<pre><code>def increment(key):
    value = None

    def do_incr(key):
        value = self.counter_table.get(key)
        if not value:
            self.counter_table.add(key, 1)
            value = 1

    with_lock(self.lock, do_incr, key)</code></pre>

<p>Better yet, the locking semantics are enforced in one place: the <code>with_lock()</code> function.</p>

<p>Note that the <code>do_incr()</code> function has access to, and can change, the parent function&#8217;s <code>value</code> object. It <em>closes over</em> any objects already in scope when it is declared, hence the term &#8220;closure&#8221;.</p>

<p>You cannot do the same thing in Java, even with an anonymous inner class, because any objects your inner class closes over must be <code>final</code>.</p>

<p>Newer versions of Python make it even easier by providing a <code>with</code> statement (available in the <code>__future__</code> module). For complete details, see <a href='http://www.python.org/dev/peps/pep-0343/'>PEP 343</a>, but here&#8217;s the general idea.</p>

<p>First, the lock API can provide a <em>context manager</em> function, like this:</p>

<pre><code>from contextlib import contextmanager

@contextmanger
def lock(the_lock):
    the_lock.lock()
    try:
        yield the_lock
    finally:
        the_lock.unlock()</code></pre>

<p>Now, the calling code becomes even more straightforward:</p>

<pre><code>from __future__ import with_statement

def increment(key):
    with lock(self.lock):
        value = self.counter_table.get(key)
        if not value:
            self.counter_table.add(key, 1)
            value = 1</code></pre>

<p>You can&#8217;t do that in Java very cleanly right now, though the various closures proposals, targeted at Java 7, attempt to address that problem. Neal Gafter&#8217;s <a href='http://gafter.blogspot.com/2006/08/use-cases-for-closures.html'>Use cases for closures</a> goes through his favored closure proposal in detail. Using that approach, you&#8217;d do something like this:</p>

<pre><code>&lt;E extends Exception&gt;
public static void withLock(Lock lock, void()throws E block) throws E 
{
    lock.lock();
    try 
    {
        block();
    }
    finally 
    {
        lock.unlock();
    }
}</code></pre>

<p>That block of code defines the method that will run my code within a lock. The Java closure proposal also adds some syntactic sugar that says, basically, &#8220;if the passed block argument is the last argument in the list, it can be specified <em>outside</em> the argument list&#8217;s final parenthesis.&#8221;</p>

<p>That means you can invoke <code>withLock()</code> like this:</p>

<pre><code>withLock(myLock)
{
    // code (closure) that operates within the lock
}</code></pre>

<p>The code between the curly braces is <em>really</em> the last argument to the <code>withLock()</code> method. And it truly <em>is</em> a closure: Unlike an anonymous inner class, the code block has read-write access to all the identifiers in the parent block&#8217;s scope.</p>

<p>I heard about the closures-in-Java proposals while I was still programming Java for my previous employer. I was very excited about the idea, since it makes a lot of programming tasks easier and safer. However, while adding closures to Java would be a good thing, they&#8217;re still not as simple as closures are in other languages, such as Python.</p>

<h2 id='array_and_string_support'>Array and String Support</h2>

<p>Both Java and Python have built-in support for strings and arrays, but Python has a lot more syntactic sugar for both, leading to simpler and more readable code. Here are some examples:</p>

<h3 id='string_or_array_slicing'>String or Array Slicing</h3>

<p>In Java, to get a &#8220;slice&#8221; out of a string, you have to use methods on the <code>java.lang.String</code> class, like so:</p>

<pre><code>String s = &quot;foo and bar&quot;

s1 = s.substring(4, 7);           // get the word &quot;and&quot;
last = s.charAt(s.length() - 1);  // get the last character in the string
first = s.charAt(0);              // get the first character in the string</code></pre>

<p>The same operations are simpler and more readable in Python:</p>

<pre><code>s = &#39;foo and bar&#39;

s1 = s[4:7]       # get the word &#39;and&#39;
last = s[-1]      # get the last character in the string
first = s[0]      # get the first character in the string</code></pre>

<p>Further, while Java allows strings to be concatenated via the &#8221;+&#8221; operator, that usage is discouraged for building up strings, since it can be inefficient. So, instead of the readable:</p>

<pre><code>message = &quot;I don&#39;t recognize the command \&quot;&quot; + s + &quot;\&quot;. Sorry.&quot;</code></pre>

<p>you end up writing:</p>

<pre><code>buf = StringBuffer()
buf.append(&quot;I don&#39;t recognize the command \&quot;&quot;);
buf.append(s);
buf.append(&quot;\&quot; Sorry.&quot;);
message = buf.toString();</code></pre>

<p>Oh, joy.</p>

<p><strong>UPDATE</strong> In the <a href='http://www.reddit.com/'>reddit.com</a> <a href='http://www.reddit.com/r/programming/'>Programming</a> forum, someone pointed out that using &#8221;+&#8221; for string concatenation isn&#8217;t really encouraged in Python, either. The author of the comment suggests one of the following, instead:</p>

<pre><code>message = &#39;I don\&#39;t recognize the command &quot;%s&quot;. Sorry.&#39; % s
message = &#39; &#39;.join([&#39;I don\&#39;t recognize the command &quot;&#39;, s, &#39;&quot;. Sorry.&#39;])</code></pre>

<p>Fair enough, but my point still holds: Both of those alternatives are more readable and shorter than the Java alternative.</p>

<p>Python also permits slicing and concatenation via &#8221;+&#8221; on arrays and tuples, not just strings. (Think of a tuple as a read-only array.) Again, this means you write less code to accomplish an array operation, and the code you do write tends to be more readable.</p>

<h2 id='dictionary_syntax'>Dictionary Syntax</h2>

<p>Python has built-in support for dictionaries (also called &#8220;associative arrays&#8221; in some languages and &#8220;hash tables&#8221; in others). In Java, you have a variety of <code>Map</code> implementations that provide the same capability, and they&#8217;re quite rich. The JDK&#8217;s <code>Map</code> interface is well-defined and sufficiently abstract. I even wrote a <a href='http://software.clapper.org/java/util/javadocs/util/api/org/clapper/util/misc/FileHashMap.html'>FileHashMap</a> class that looks like a <code>Map</code>, but keeps its values in a file rather than in memory.</p>

<p>But Java does not have built-in syntax support for maps, so dealing with them requires more code. Consider this simple example, a symbol table of keywords. Let&#8217;s assume the existence of a <code>Symbol</code> class that captures information about a symbol (the line where it&#8217;s defined, its type, etc.).</p>

<pre><code>public class SymbolTable
{
    private Map&lt;String,Symbol&gt; symbols = new HashMap&lt;String,Symbol&gt;();

    // ...

    public Symbol getSymbol(String identifier)
    {
        // Get or create the symbol

        Symbol sym = symbols.get(identifier);
        if (sym == null)
        {
            sym = Symbol(identifier);
            symbols.put(identifier);
        }

        return sym;
    }
}</code></pre>

<p>Here&#8217;s the equivalent Python code:</p>

<pre><code>class SymbolTable(object):

    symbols = {}

    def get_symbol(identifier):
        try:
            sym = symbols[identifier]
        except KeyError:
            sym = Symbol(identifier)
            symbols[identifier] = sym

        return sym</code></pre>

<p>It may seem like I&#8217;m nit-picking, but the Python approach just seems simpler and more natural. (And believe me, I&#8217;ve used my share of Java <code>Map</code> classes over the years.)</p>

<h1 id='observation_4_introspection_is_easier_in_python'>Observation 4: Introspection is easier in Python</h1>

<p>This is a big one. Both Java and Python carry object information around at run time, and you can query that information programmatically. But it&#8217;s a pain in the ass in Java.</p>

<p>Let&#8217;s suppose you want to write a function that&#8217;ll take <em>any</em> object that has a method with this signature:</p>

<pre><code>boolean compare(String s1, String s2);</code></pre>

<p>Further, you don&#8217;t want to constrain the objects to implementing a specific interface. (Though this situation doesn&#8217;t sound likely, and isn&#8217;t something you&#8217;d normally want to do, it <em>does</em> come up.)</p>

<p>To do that in Java requires resorting to the <a href='http://java.sun.com/docs/books/tutorial/reflect/index.html'>Reflection API</a>. Here&#8217;s the code you have to write to verify that the object has such a method, and then to call that method with two strings:</p>

<pre><code>import java.lang.reflect.Method;

...

    public Object callCompare(Object o, String s1, String s2)
    {
        Class cls = o.getClass();

        try
        {
            Method method = cls.getMethod(&quot;compare&quot;, String.class, String.class);
            return method.invoke(o, s1, s2);
        }

        catch (NoSuchMethodException ex)
        {
            ...
        }

        catch (IllegalAccessException ex)
        {
            ...
        }

        catch (IllegalArgumentException ex)
        {
            ...
        }

        catch (InvocationTargetException ex)
        {
            ...
        }</code></pre>

<p>That code is ugly for a few reasons. (It used to be worse, before Java 5 introduced variable arguments.)</p>

<ul>
<li>All those exceptions either have to be caught or propagated.</li>

<li>If the method itself throws an exception, it&#8217;ll be wrapped in an <code>InvocationTargetException</code>, and you have to unwrap it if you want to re-throw the real exception.</li>

<li>Does the above code look like it&#8217;s calling an object&#8217;s <code>compare()</code> method to <em>you</em>?</li>
</ul>

<p>Here&#8217;s how you do the same thing in Python:</p>

<pre><code>o = ...
s1 = ...
s2 = ...

try:
    result = o.compare(s1, s2)
except AttributeError:
    # Doesn&#39;t have that method.
    ...</code></pre>

<p>In addition to being short and to-the-point, the Python code actually <em>looks</em> like what it&#8217;s doing.</p>

<h1 id='observation_5_python_has_an_rich_library'>Observation 5: Python has an rich library</h1>

<p>I mention this one only because Java also has a rich library. Between the JDK and the open source Java code out there, there&#8217;s lots of help building Java applications.</p>

<p>When I started doing a lot of Python, I found the same thing to be true, so I didn&#8217;t lose anything there.</p>

<p>There <em>is</em> this sense, though, that a lot of things are just easier in Python. For instance, the <a href='http://www.djangoproject.com/'>Django</a> web framework makes incrementally building an application so easy, it&#8217;s ridiculous. It&#8217;s much easier to get started with Django than with even a <em>simple</em> Java web container like <a href='http://tomcat.apache.org/'>Tomcat</a>. (Of course, this isn&#8217;t evidence; it&#8217;s an anecdote. You&#8217;re free to draw your own conclusions.)</p>

<h1 id='observation_6_dynamic_typing_a_mixed_bag'>Observation 6: Dynamic Typing (a mixed bag)</h1>

<p>I mention <a href='http://en.wikipedia.org/wiki/Type_system#Dynamic_typing'>dynamic typing</a> because so many people either tout it as the best thing since sliced luncheon meats or decry it as an evil feature considered as harmful as the GOTO statement. Reality, of course, is somewhere in between&#8211;as is my experience.</p>

<p>There <em>are</em> more carefully considered opinions, of course, but they tend to get lost in the noise. See, for instance, an excellent paper entitled <a href='http://pico.vub.ac.be/~wdmeuter/RDL04/papers/Meijer.pdf'>Static Typing Where Possible, Dynamic Typing When Needed</a> (PDF) for a good and balanced discussion of the issue.</p>

<p>I&#8217;m not going to waste time debating which one is &#8220;better&#8221; (for some values of &#8220;better&#8221;). There are plenty of people who do a better job of that than I will. (Start with the paper I just mentioned, for instance.) I&#8217;m just going to share my own experiences with the two approaches, using Java and Python as my examples.</p>

<p>Recall that Java is statically typed, which has several advantages.</p>

<h2 id='compilertime_checks'>Compiler-time checks</h2>

<p>First, the compiler can ensure that you don&#8217;t assign the wrong type of object to a variable or pass the wrong type of object to a method (unless, of course, you use type casting to thwart the compiler, but good Java programmers try to avoid having to cast).</p>

<p>I have long been a fan of compile-time protection. The more problems the compiler can find for you, the fewer things you have to root out at run time. Oddly enough, though, I haven&#8217;t found the lack of compile time type checking to be a big problem with Python so far. I suspect this is because I&#8217;ve been writing well-encapsulated code with lots of automated unit tests. A paper called <a href='http://www.chimu.com/publications/short/whyDynamicTyping.html'>Why dynamic typing?</a> puts it this way:</p>

<blockquote>
<p>Why does dynamic typing (as done with Smalltalk) not negatively affect the stability of large applications?</p>

<p>Because large applications written in a dynamic OO language still have well encapsulated parts that can be verified independently, and the total implementation can be about 1/2 to 1/3 the size of the implementation in Java (or another static-typed language)</p>

<p>In the small you may get a type error that static-typing could have [caught], but you also get to build a system such that you never have to write 40-70% of the code you might otherwise have to. And a line of code not written is a 100% guaranteed correct line of code.</p>
</blockquote>

<p>It&#8217;s an interesting argument. I&#8217;m not sure I agree completely with the last statement, but there&#8217;s merit in the observations.</p>

<p>For me, so far, the lack of compile-time type protection in Python simply hasn&#8217;t been as big a deal as I thought it would be.</p>

<p><strong>UPDATE</strong>: Over time, it turned out to be quite a big deal, which is why I&#8217;ve migrated to <a href='http://www.scala-lang.org/'>Scala</a>; it offers a similar brevity of expression, while being compile-time type-safe.</p>

<h2 id='syntaxbased_introspection'>Syntax-based introspection</h2>

<p>Another advantage of static typing is that IDEs can tell a variable&#8217;s type no matter where it appears, which is a boon for things like auto-completion.</p>

<p>This is where I&#8217;ve most noticed the lack of type information. Lately, I&#8217;ve been using the excellent <a href='http://www.wingware.com/'>Wing</a> IDE to develop Python. (Why I&#8217;m using Wing instead of my old trusty friend, Emacs, is a subject for a future article.) Unlike any Java IDE, there are cases where Wing just cannot tell the type of a variable and, therefore, cannot help me determine what fields and methods that variable provides. Here&#8217;s a case where it <em>can</em> tell:</p>

<pre><code>my_foo = Foo()

my_foo.a
        ^</code></pre>

<p>If I invoke auto-completion where the caret is, Wing can show me all attributes that start with &#8220;a&#8221;, because the assignment of a <code>Foo</code> object to <code>my_foo</code> is within scope.</p>

<p>However, here&#8217;s a case where it cannot tell:</p>

<pre><code>def somefunc(foo):
    foo.a
         ^</code></pre>

<p>At runtime, the argument <code>foo</code> can be anything, so the IDE cannot tell what fields it might have (other than, of course, the fields that all Python objects have).</p>

<p>Sometimes, I miss the ability for the IDE (or any other tool) to be able to introspect a variable by syntactic analysis, but it honestly hasn&#8217;t been enough of an issue to take the fun out of Python.</p>

<h1 id='observation_7_the_interactive_shell'>Observation 7: The Interactive Shell</h1>

<p>Python comes with an interactive shell, and there&#8217;s an even better one (IPython) available for free. When I&#8217;m not sure how something works, or I want to try something manually, or run a quick test, I can simply fire up the Python shell and try the code, right then and there. (Ruby and other so-called scripting languages have similar tools.)</p>

<p>It&#8217;s impossible to overstate the usefulness of a command-line interface to the language interpreter. Nothing quite like it exists for Java. The <a href='http://www.beanshell.org/'>BeanShell</a> console comes close, but the latest version as of this writing doesn&#8217;t fully support Java 5. (It&#8217;s missing support for generics, for instance.)</p>

<p><a href='http://blogs.open.collab.net/oncollabnet/'>Jack Repenning</a> also pointed out, in a private email, that the brevity argument applies here, as well:</p>

<blockquote>
<p>Even in environments with a fairly competent Java Interactive Shell, what you have to type in is still Java, and the extra prolixity of Java hurts all the more when you&#8217;re just trying to confirm the results of a function call, or the shape of an object, or any of those other explorations the interactive shell is so good at.</p>
</blockquote>

<h1 id='final_comments'>Final Comments</h1>

<p>I&#8217;m sure there are differences I&#8217;ve missed. And, as I noted above, I&#8217;m not trying to convince anyone who uses Java that it&#8217;d be better to jump ship and join the <a href='http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html'>Pythonistas</a>.</p>

<p>I used Java for a long time, and I&#8217;m sure I&#8217;ll do more work in Java. Nor will I complain a lot if I have to do so. Both Java and Python (as well as Ruby and other languages) allow me to develop and test my software on any platform, unlike (say) most <a href='http://en.wikipedia.org/wiki/C_Sharp'>C#</a> work, which locks me into a platform I don&#8217;t like all that much (Mono notwithstanding).</p>

<p>I&#8217;m just trying to figure out why Python is so damned fun.</p>

<p>Time to stop thinking for a bit and have some fun&#8230;</p>

<h1 id='update_29_july_2008'>UPDATE: 29 July, 2008</h1>

<p>I have received some emailed comments. Thanks to everyone who took the time to send me a comment.</p>

<p>Both Dan Barbus <em>dan.barbus /at/ gmail.com</em> and Simon Lieschke <em>simon at lieschke.net</em> pointed out an oversight. My original Python <code>matches()</code> function (see <a href='#callbacks'>Callbacks</a>, above) was written like this:</p>

<pre><code>def matches(self, match_func):
    for element in self.__tree_elements:
        if match_func(element):
            result.append(element)

    return result</code></pre>

<p>Both Dan and Simon pointed out that the function can be reduced to a one-liner:</p>

<pre><code>def matches(self, match_func):
    return [element for element in self.__tree_elements if match_func(element)]</code></pre>

<p>One-liner list comprehensions like that are one of the things I like about Python, and I&#8217;m not sure why I wrote the function the &#8220;long&#8221; way originally. Chalk it up to a brain fart.</p>
<hr />
<p>Michael Easter (<em>codetojoy /at/ gmail.com</em>) noted out that, like <a href='http://www.beanshell.org/'>BeanShell</a>, <a href='http://groovy.codehaus.org/'>Groovy</a> also has a shell that allows interpretative Java. So does <a href='https://pnuts.dev.java.net/'>Pnuts</a>, a very fast Java scripting language I&#8217;ve used quite heavily in the past. These are good tools to keep in one&#8217;s Java toolbox.</p>
<hr />
<p>Fred van Dijk (<em>fredvd /at/ gmail.com</em>) pointed out a cut-and-paste typo in one of my examples. Thanks, Fred.</p>
<hr />
<p>Florian Bosch (<em>pyalot /at/ gmail.com</em>) wrote:</p>

<blockquote>
<p>I&#8217;ve read your article and I think I you might find my perspective on dynamic typing also interesting, and why it actually works, and works very well.</p>

<p>To my shame I have to admit I&#8217;m not a big user of unit tests. I&#8217;ve used them to great effect sometimes, and some software I wrote has a lot of them, but generally there&#8217;s very little of it around my code.</p>

<p>On any account, python still is making me way more productive, and if your argument was true, that your unit tests safe you from being harmed by dynamic typing, then I would be burned badly, but I am not. I think I can explain that.</p>

<p>Put simply, I think typing does not essentially catch the larger domain of logical errors that happen during programming. However, it does introduce considerable overhead. Logically, when you take typing constraints away, a small amount of errors that would&#8217;ve been cought before slip by to runtime, however you get a lot less overhead to deal with, which more then makes this up.</p>

<p>Put not so simply, Typing is a school of formalism that attempts to describe a systems constraints in terms of types involved. That is a special form of a constraint system, like clipse or prolog. These systems work great for specific domains, but they&#8217;re not a great way to do all things. Enforcing constraint oriented programming on all parts of your code is not a very smart idea to increase productivity, because most code actually does not benefit from that particular flavor of constraint system.</p>
</blockquote>

<p>Fair enough, though there are still times where I want both (or either). Florian followed up with:</p>

<blockquote>
<p>Python actually has strong types, as opposed to say PHP or Perl. And you absolutely can write static looking code today in python, for instance:</p>

<pre><code>@types(int, str)
def foo(arg1, arg2):
    pass</code></pre>

<p>And annotations for python loom on the horizon, which would make it possible to write things like this:</p>

<pre><code>@typechecked
def foo(int arg1, str arg2):
    pass</code></pre>
</blockquote>

<p>I&#8217;m not sure if this is coming in Python 3000 or not. (If someone knows, please enlighten me.) I know that there are already some packages out there that provide similar annotations, such as:</p>

<ul>
<li>The <a href='http://oakwinter.com/code/typecheck/'>typecheck</a> module provides various typechecking features, including an <code>@accepts</code> annotation that looks a lot like the <code>@type</code> annotation noted above.</li>

<li><a href='http://www.fightingquaker.com/pyanno/'>Pyanno</a> also has some typechecking annotations.</li>
</ul>

<h1 id='update_16_september_2008'>UPDATE: 16 September, 2008</h1>

<p>Jésus Gómez (<em>jgomo3 /at/ gmail.com</em>) wrote:</p>

<blockquote>
<p>About Observation 3 and factories.</p>

<p>You could avoid the use of (and maintaining the) dict you use in this code:</p>

<pre><code>RPC_CLASSES = {&#39;xmlrpc&#39;  : XMLRPC,
               &#39;jsonrpc&#39; : JSONRPC,
               ... }

def get_rpc(identifier):
   try:
       return RPC_CLASSES[identifier]()
   except KeyError:
       raise ValueError, &#39;&quot;%s&quot; is an unknown RPC type&#39; % identifier</code></pre>

<p>by redefining the <code>get_rpc</code> function as:</p>

<pre><code>def get_rpc(identifier):
   try:
       return getattr(&lt;&lt;module_which_define_the_classes&gt;&gt;, identifier)()
   except KeyError:
       raise AttributeError, &#39;&quot;%s&quot; is an unknown RPC type&#39; % identifier</code></pre>

<p>Take a look at the <a href='http://diveintopython.org/toc/index.html'>Dive Into Python</a> chapter on classes for a fun way to declare classes to act like dictionaries, useful for your <a href='#dictionary_syntax'>Dictionary Syntax</a> section.</p>
</blockquote>

<h1 id='update_13_october_2008'>UPDATE: 13 October, 2008</h1>

<p>Regarding my <code>get_symbol()</code> method, in the section on <a href='#dictionary_syntax'>Dictionary Syntax</a>, Kevin Samuel (<em>info.ksamuel</em> /at/ <em>googlemail.com</em>) wrote:</p>

<blockquote>
<p>I&#8217;d like to share a little trick. When you say:</p>

<pre><code>class SymbolTable(object):

    symbols = {}

    def get_symbol(identifier):
        try:
            sym = symbols[identifier]
        except KeyError:
            sym = Symbol(identifier)
            symbols[identifier] = sym

        return sym</code></pre>

<p>You could just use the built-in:</p>

<pre><code>d = {}
value = d.setdefault(identifier, default_value)</code></pre>

<p><code>setdefault</code> is a bad name since it does return a value or the default value (or <code>None</code> is no value is given).</p>
</blockquote>

<p>The <a href='http://www.python.org/doc/2.5.2/lib/typesmapping.html'>Python documentation on dictionaries</a> says:</p>

<blockquote>
<p><em>a</em> <code>.setdefault</code> (<em>k</em>[, <em>x</em>]) returns <em>a</em>[<em>k</em>] if <em>k</em> in <em>a</em>, else <em>x</em> (also setting it)</p>
</blockquote>

<p>It further elaborates:</p>

<blockquote>
<p><code>setdefault()</code> is like <code>get()</code>, except that if <em>k</em> is missing, <em>x</em> is both returned and inserted into the dictionary as the value of <em>k</em>. <em>x</em> defaults to <code>None</code>.</p>
</blockquote>

<p>I confess that I missed this behavior when I read the Python documentation. Thanks, Kevin.</p>
</div>

<br/><br/>

<div class="article-footer">
<a href="/id/75/index.html" class="reference">Permalink</a> |
<a href="printable.html" class="reference">Printer-friendly</a> |
<span class="tags">Tags: 

<a href="/tags/java/">java</a>,

<a href="/tags/programming/">programming</a>,

<a href="/tags/python/">python</a>

</span>
</div>


<script type="text/javascript">
createTOC();
</script>


<a href="#disqus_thread">Comments</a>

<div id="disqus_thread"></div>

<script type="text/javascript">
  // Use the base file name (without the ".html") as the Disqus URL. This is
  // necessary to be consistent with old version of Brizzled on App Engine.
  
  var disqus_identifier = "http://brizzled.clapper.org/id/75/";
  var disqus_url = "http://brizzled.clapper.org/id/75/";
  
  var disqus_title = "Brizzled: Why is Python more fun than Java?";

  

  (function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = 'http://brizzled.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();

</script>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=brizzled">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

</div>

</div>
</div>

<script type="text/javascript">
//<![CDATA[
(function() {
	var links = document.getElementsByTagName('a');
	var query = '?';
	for(var i = 0; i < links.length; i++) {
	if(links[i].href.indexOf('#disqus_thread') >= 0) {
		query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
	}
	}
	document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/brizzled/get_num_replies.js' + query + '"></' + 'script>');
})();
//]]>
</script>





</div>
<br clear="all"/>
<div class="page-footer">
Copyright &copy; 2005-2010 Brian M. Clapper&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This page was generated with <a href="http://jekyllrb.com/">Jekyll</a>. 
</div>
</body>
</html>

